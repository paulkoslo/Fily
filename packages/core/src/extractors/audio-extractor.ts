import * as fs from 'fs';
import * as path from 'path';
import OpenAI from 'openai';
import type { Extractor, ExtractionResult, ExtractedContent } from './types';
import type { WorkerPool } from '../agents/worker-pool';

/**
 * Audio/Video Extractor - transcribes speech using OpenAI Whisper API
 * Supports: .mp3, .wav, .flac, .aac, .ogg, .m4a, .mp4, .mov, .avi, .mkv, .webm, .m4v
 * 
 * Each Whisper API call counts as 1 worker in the worker pool.
 */
export class AudioExtractor implements Extractor {
  readonly id = 'audio-extractor';
  readonly version = '1.0.0';
  
  readonly supportedExtensions = [
    'mp3', 'wav', 'flac', 'aac', 'ogg', 'm4a', 'opus',
    'mp4', 'mov', 'avi', 'mkv', 'webm', 'm4v', 'wmv', 'flv',
  ];

  private openai: OpenAI | null = null;
  private workerPool: WorkerPool | null = null;

  constructor(workerPool?: WorkerPool) {
    const apiKey = process.env.OPENAI_API_KEY;
    if (apiKey) {
      this.openai = new OpenAI({ apiKey });
    } else {
      console.warn('[AudioExtractor] OPENAI_API_KEY not found, audio extraction will be skipped');
    }
    this.workerPool = workerPool || null;
  }

  canExtract(extension: string): boolean {
    return this.supportedExtensions.includes(extension.toLowerCase()) && this.openai !== null;
  }

  async extract(filePath: string, extension: string): Promise<ExtractionResult> {
    if (!this.openai) {
      return {
        success: false,
        content: null,
        error: 'OpenAI API key not configured',
        extractorVersion: this.version,
      };
    }

    try {
      // Check file size (OpenAI has 25MB limit for audio)
      const stats = fs.statSync(filePath);
      const maxSize = 25 * 1024 * 1024; // 25MB
      if (stats.size > maxSize) {
        return {
          success: false,
          content: null,
          error: `Audio/video too large (${Math.round(stats.size / 1024 / 1024)}MB), skipping`,
          extractorVersion: this.version,
        };
      }

      // Read file
      const fileBuffer = await fs.promises.readFile(filePath);
      
      // Create a File-like object for OpenAI API
      // Note: OpenAI Whisper API expects a File object, but in Node.js we need to use FormData
      // We'll use the file buffer directly with the API
      const fileName = path.basename(filePath);
      const mimeType = this.getMimeType(extension);
      
      // Create a File object using the buffer
      // In Node.js, we need to use a polyfill or create a File-like object
      // OpenAI SDK accepts ReadStream or Buffer, so we can pass the buffer directly
      const file = new File([fileBuffer], fileName, { type: mimeType });

      // Transcribe using Whisper (counts as 1 worker)
      const transcriptionCall = async () => {
        const transcription = await this.openai!.audio.transcriptions.create({
          file: file,
          model: 'whisper-1',
          language: 'en', // Can be made configurable later
        });
        return transcription.text || '';
      };

      // Use worker pool if available, otherwise execute directly
      const text = this.workerPool
        ? await this.workerPool.execute(transcriptionCall)
        : await transcriptionCall();
      const keywords = this.extractKeywords(text, extension);
      
      // Extractors only extract raw content - classification is done by agents
      const summary: string | null = null;
      
      const isVideo = ['mp4', 'mov', 'avi', 'mkv', 'webm', 'm4v', 'wmv', 'flv'].includes(extension.toLowerCase());
      const extractedContent: ExtractedContent = {
        contentType: isVideo ? 'video' : 'audio',
        extractedText: text, // Full transcription
        summary: null, // Summary will be generated by classification agent
        keywords,
        metadata: {
          size: stats.size,
          extension,
        },
      };

      return {
        success: true,
        content: extractedContent,
        extractorVersion: this.version,
      };
    } catch (error) {
      return {
        success: false,
        content: null,
        error: error instanceof Error ? error.message : 'Unknown error',
        extractorVersion: this.version,
      };
    }
  }

  private getMimeType(extension: string): string {
    const mimeTypes: Record<string, string> = {
      mp3: 'audio/mpeg',
      wav: 'audio/wav',
      flac: 'audio/flac',
      aac: 'audio/aac',
      ogg: 'audio/ogg',
      m4a: 'audio/mp4',
      mp4: 'video/mp4',
      mov: 'video/quicktime',
      avi: 'video/x-msvideo',
      mkv: 'video/x-matroska',
      webm: 'video/webm',
    };
    return mimeTypes[extension.toLowerCase()] || 'audio/mpeg';
  }

  private extractKeywords(text: string, extension: string): string[] {
    const keywords: string[] = [extension.toLowerCase()];
    
    // Simple keyword extraction
    const commonTerms = ['meeting', 'call', 'interview', 'lecture', 'presentation',
                         'music', 'song', 'podcast', 'audio', 'video'];
    
    const lowerText = text.toLowerCase();
    for (const term of commonTerms) {
      if (lowerText.includes(term)) {
        keywords.push(term);
      }
    }
    
    return [...new Set(keywords)];
  }
}
