import * as fs from 'fs';
import pdf from 'pdf-parse';
import type { Extractor, ExtractionResult, ExtractedContent } from './types';

/**
 * PDF Extractor - extracts text from PDF files
 * Supports: .pdf
 */
export class PDFExtractor implements Extractor {
  readonly id = 'pdf-extractor';
  readonly version = '1.0.0';
  
  readonly supportedExtensions = ['pdf'];

  canExtract(extension: string): boolean {
    return this.supportedExtensions.includes(extension.toLowerCase());
  }

  async extract(filePath: string, extension: string): Promise<ExtractionResult> {
    try {
      // Check file size (skip files larger than 50MB)
      const stats = fs.statSync(filePath);
      const maxSize = 50 * 1024 * 1024; // 50MB
      if (stats.size > maxSize) {
        return {
          success: false,
          content: null,
          error: `PDF too large (${Math.round(stats.size / 1024 / 1024)}MB), skipping`,
          extractorVersion: this.version,
        };
      }

      const dataBuffer = await fs.promises.readFile(filePath);
      // Suppress pdf-parse font warnings (they're harmless)
      const originalConsoleWarn = console.warn;
      console.warn = (...args: any[]) => {
        const msg = args[0]?.toString() || '';
        // Filter out pdf-parse font warnings
        if (!msg.includes('TT: undefined function')) {
          originalConsoleWarn.apply(console, args);
        }
      };
      
      let pdfData;
      try {
        pdfData = await pdf(dataBuffer);
      } finally {
        // Restore console.warn
        console.warn = originalConsoleWarn;
      }
      
      const extractedText = pdfData.text || '';

      // Heuristic: if pdf-parse returns no text at all, treat this as an image-based (scanned) PDF
      const hasText = extractedText.trim().length > 0;

      let extractedContent: ExtractedContent;

      if (!hasText) {
        // Image-based / scanned PDF: store original binary as "image" payload for the Summary Agent to OCR
        extractedContent = {
          contentType: 'pdf',
          extractedText: '', // No text available from pdf-parse
          summary: null,
          keywords: ['pdf', 'image-based', 'scan'],
          metadata: {
            pages: pdfData.numpages,
            title: pdfData.info?.Title || null,
            author: pdfData.info?.Author || null,
            subject: pdfData.info?.Subject || null,
            creator: pdfData.info?.Creator || null,
            producer: pdfData.info?.Producer || null,
            creationDate: pdfData.info?.CreationDate || null,
            modDate: pdfData.info?.ModDate || null,
            // Flags and payload for downstream agents
            isImageBased: true,
            // Store original PDF bytes so the Summary Agent can attempt vision/OCR as a fallback
            pdfBuffer: dataBuffer.toString('base64'),
            mimeType: 'application/pdf',
          },
        };
      } else {
        // Text-based PDF (normal case)
        // Extractors only extract raw content - classification is done by agents
        const summary: string | null = null;
        
        // Extract keywords from PDF text
        const keywords = this.extractKeywords(extractedText);
        
        extractedContent = {
          contentType: 'pdf',
          extractedText,
          summary: null, // Summary will be generated by classification agent
          keywords,
          metadata: {
            pages: pdfData.numpages,
            title: pdfData.info?.Title || null,
            author: pdfData.info?.Author || null,
            subject: pdfData.info?.Subject || null,
            creator: pdfData.info?.Creator || null,
            producer: pdfData.info?.Producer || null,
            creationDate: pdfData.info?.CreationDate || null,
            modDate: pdfData.info?.ModDate || null,
            isImageBased: false,
          },
        };
      }

      return {
        success: true,
        content: extractedContent,
        extractorVersion: this.version,
      };
    } catch (error) {
      return {
        success: false,
        content: null,
        error: error instanceof Error ? error.message : 'Unknown error',
        extractorVersion: this.version,
      };
    }
  }

  private extractKeywords(text: string): string[] {
    const keywords: string[] = ['pdf'];
    
    // Simple keyword extraction (can be improved)
    const commonWords = ['invoice', 'receipt', 'report', 'document', 'contract',
                         'agreement', 'proposal', 'presentation', 'manual', 'guide'];
    
    const lowerText = text.toLowerCase();
    for (const word of commonWords) {
      if (lowerText.includes(word)) {
        keywords.push(word);
      }
    }
    
    return [...new Set(keywords)];
  }
}
