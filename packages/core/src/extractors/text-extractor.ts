import * as fs from 'fs';
import type { Extractor, ExtractionResult, ExtractedContent } from './types';

/**
 * Text Extractor - extracts text from plain text files and code files
 * Supports: .txt, .md, .json, .yaml, .yml, .xml, .csv, .log, .env, .ini, .conf,
 * .js, .ts, .jsx, .tsx, .py, .rb, .go, .rs, .java, .c, .cpp, .h, .hpp, .swift,
 * .kt, .sh, .bash, .zsh, .html, .css, .scss, .less, .sql, .r, .m, .swift, etc.
 */
export class TextExtractor implements Extractor {
  readonly id = 'text-extractor';
  readonly version = '1.0.0';
  
  readonly supportedExtensions = [
    // Plain text
    'txt', 'md', 'markdown', 'readme', 'license', 'changelog', 'authors', 'contributors',
    // Data formats
    'json', 'yaml', 'yml', 'xml', 'csv', 'tsv', 'toml', 'ini', 'conf', 'cfg', 'env',
    // Code files
    'js', 'jsx', 'mjs', 'cjs', 'ts', 'tsx', 'py', 'pyw', 'rb', 'go', 'rs', 'java',
    'c', 'cpp', 'cc', 'cxx', 'h', 'hpp', 'hh', 'hxx', 'swift', 'kt', 'scala',
    'clj', 'cljs', 'hs', 'ml', 'fs', 'fsx', 'vb', 'cs', 'php', 'pl', 'pm', 'r',
    'm', 'mm', 'sh', 'bash', 'zsh', 'fish', 'ps1', 'bat', 'cmd',
    // Web
    'html', 'htm', 'xhtml', 'css', 'scss', 'sass', 'less', 'styl', 'vue', 'svelte',
    // SQL
    'sql', 'sqlite', 'db',
    // Logs
    'log', 'out', 'err',
    // Config
    'gitignore', 'dockerfile', 'makefile', 'cmake', 'gradle', 'maven',
    // Other text
    'rtf', 'tex', 'latex', 'bib', 'org', 'rst', 'asciidoc', 'adoc',
  ];

  canExtract(extension: string): boolean {
    return this.supportedExtensions.includes(extension.toLowerCase());
  }

  async extract(filePath: string, extension: string): Promise<ExtractionResult> {
    try {
      // Check file size (skip files larger than 10MB to avoid memory issues)
      const stats = fs.statSync(filePath);
      const maxSize = 10 * 1024 * 1024; // 10MB
      if (stats.size > maxSize) {
        return {
          success: false,
          content: null,
          error: `File too large (${Math.round(stats.size / 1024 / 1024)}MB), skipping`,
          extractorVersion: this.version,
        };
      }

      // Read file as UTF-8
      // Extractors only extract raw content - classification is done by agents
      const content = await fs.promises.readFile(filePath, 'utf-8');
      
      // No summary here - that's the agent's job
      const summary: string | null = null;
      
      // Extract keywords (simple approach: common words, can be improved later)
      const keywords = this.extractKeywords(content, extension);
      
      const extractedContent: ExtractedContent = {
        contentType: 'text',
        extractedText: content,
        summary: null, // Summary will be generated by classification agent
        keywords,
        metadata: {
          size: stats.size,
          lineCount: content.split('\n').length,
          extension,
        },
      };

      return {
        success: true,
        content: extractedContent,
        extractorVersion: this.version,
      };
    } catch (error) {
      // File might be binary or corrupted
      return {
        success: false,
        content: null,
        error: error instanceof Error ? error.message : 'Unknown error',
        extractorVersion: this.version,
      };
    }
  }

  private extractKeywords(content: string, extension: string): string[] {
    const keywords: string[] = [];
    
    // Add extension as keyword
    keywords.push(extension.toLowerCase());
    
    // Simple keyword extraction: look for common patterns
    // TODO: Can be improved with NLP later
    
    // Look for common code patterns
    if (['js', 'ts', 'jsx', 'tsx'].includes(extension.toLowerCase())) {
      if (content.includes('import') || content.includes('require')) keywords.push('imports');
      if (content.includes('export') || content.includes('module.exports')) keywords.push('exports');
      if (content.includes('function') || content.includes('=>')) keywords.push('functions');
      if (content.includes('class ')) keywords.push('classes');
      if (content.includes('interface ') || content.includes('type ')) keywords.push('types');
    }
    
    if (extension.toLowerCase() === 'py') {
      if (content.includes('import ')) keywords.push('imports');
      if (content.includes('def ')) keywords.push('functions');
      if (content.includes('class ')) keywords.push('classes');
    }
    
    // Look for common document patterns
    if (['md', 'markdown'].includes(extension.toLowerCase())) {
      if (content.includes('# ')) keywords.push('markdown');
      if (content.includes('```')) keywords.push('code-blocks');
    }
    
    // Look for config patterns
    if (['json', 'yaml', 'yml'].includes(extension.toLowerCase())) {
      keywords.push('config');
      if (content.includes('"name"') || content.includes('name:')) keywords.push('package-config');
    }
    
    return [...new Set(keywords)]; // Deduplicate
  }
}
