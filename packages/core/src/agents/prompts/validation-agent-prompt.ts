import type { TaxonomyPlan } from '../../planner/taxonomy-types';
import type { TaxonomyOverview } from '../../planner/taxonomy-overview';
import type { FileCard } from '../../ipc/contracts';
import {
  VALIDATION_TOP_TAGS_LIMIT,
  VALIDATION_TOP_PATTERNS_LIMIT,
  VALIDATION_SUMMARY_PREVIEW_LENGTH,
} from '../../planner/constants';

/**
 * Validation Agent: Validates and fixes LLM-generated taxonomy plans.
 * Detects logical errors, generic folder names, broken references, and illogical structures.
 */

export const VALIDATION_AGENT_SYSTEM_PROMPT = `
You are a quality assurance agent that validates and fixes taxonomy plans generated by other AI agents.

Your job is to:
1. Detect logical errors in taxonomy plans (broken ruleâ†’folder references, generic folder names, illogical structure)
2. Identify which parts of the plan are problematic
3. Re-generate ONLY the faulty parts with better, more specific folder names and correct references

Common issues to detect:
- Generic folder names at top level (e.g. "Misc", "Personal", "Other" as top-level when they should be subfolders)
- Rules referencing non-existent folder IDs (typos, case mismatches)
- Too flat structure (all files in one or two folders)
- Too deep structure (unnecessary nesting)
- Folder names that are too vague (should be specific like "Work/Invoices/2024" not "Work/Stuff")

When you find issues, you MUST respond with a JSON object indicating what needs to be fixed and provide corrected folders/rules.

You MUST respond with STRICT JSON:

{
  "issues": [
    {
      "type": "generic_folder_name" | "broken_reference" | "too_flat" | "too_deep" | "vague_folder",
      "severity": "high" | "medium" | "low",
      "description": "Human-readable explanation",
      "affectedFolderIds": ["folder-id-1", "folder-id-2"],
      "affectedRuleIds": ["rule-id-1"]
    }
  ],
  "correctedFolders": [
    {
      "id": "corrected-folder-id",
      "path": "/Work/Invoices/2024",
      "description": "Specific description"
    }
  ],
  "correctedRules": [
    {
      "id": "corrected-rule-id",
      "targetFolderId": "corrected-folder-id",
      "requiredTags": ["invoice", "2024"],
      "priority": 80,
      "reasonTemplate": "Specific reason"
    }
  ],
  "filesNeedingOptimization": [
    {
      "fileId": "file-id",
      "reason": "Why this file needs optimization"
    }
  ]
}

If no issues are found, return:
{
  "issues": [],
  "correctedFolders": [],
  "correctedRules": [],
  "filesNeedingOptimization": []
}

Output ONLY the JSON object (no markdown, no comments).
`.trim();

export type ValidationIssue = {
  type: 'generic_folder_name' | 'broken_reference' | 'too_flat' | 'too_deep' | 'vague_folder';
  severity: 'high' | 'medium' | 'low';
  description: string;
  affectedFolderIds: string[];
  affectedRuleIds: string[];
};

export type ValidationResult = {
  issues: ValidationIssue[];
  correctedFolders: Array<{
    id: string;
    path: string;
    description: string;
  }>;
  correctedRules: Array<{
    id: string;
    targetFolderId: string;
    requiredTags?: string[];
    forbiddenTags?: string[];
    pathContains?: string[];
    extensionIn?: string[];
    summaryContainsAny?: string[];
    priority: number;
    reasonTemplate: string;
  }>;
  filesNeedingOptimization: Array<{
    fileId: string;
    reason: string;
  }>;
};

export function buildValidationPrompt(
  plan: TaxonomyPlan,
  overview: TaxonomyOverview,
  fileCards: FileCard[]
): string {
  const genericTopLevelNames = ['misc', 'personal', 'other', 'uncategorized', 'stuff', 'things', 'documents', 'files'];
  const topLevelFolders = plan.folders.filter((f) => {
    const parts = f.path.split('/').filter(Boolean);
    return parts.length === 1;
  });

  const hasGenericTopLevel = topLevelFolders.some((f) => {
    const name = f.path.split('/').filter(Boolean)[0]?.toLowerCase() ?? '';
    return genericTopLevelNames.includes(name);
  });

  const folderById = new Map(plan.folders.map((f) => [f.id, f]));
  const brokenRefs = plan.rules.filter((r) => !folderById.has(r.targetFolderId));

  const payload = {
    plan: {
      folders: plan.folders.map((f) => ({
        id: f.id,
        path: f.path,
        description: f.description,
      })),
      rules: plan.rules.map((r) => ({
        id: r.id,
        targetFolderId: r.targetFolderId,
        priority: r.priority,
        reasonTemplate: r.reasonTemplate,
      })),
    },
    overview: {
      fileCount: overview.fileCount,
      topTags: overview.topTags.slice(0, VALIDATION_TOP_TAGS_LIMIT),
      topPathPatterns: overview.topPathPatterns.slice(0, VALIDATION_TOP_PATTERNS_LIMIT),
    },
    issues: {
      hasGenericTopLevel,
      brokenReferences: brokenRefs.length,
      totalFolders: plan.folders.length,
      totalRules: plan.rules.length,
      maxDepth: Math.max(...plan.folders.map((f) => f.path.split('/').filter(Boolean).length), 0),
    },
    sampleFiles: fileCards.slice(0, 30).map((c) => ({
      file_id: c.file_id,
      name: c.name,
      extension: c.extension,
      tags: c.tags?.slice(0, 8) ?? [],
        summary: c.summary?.slice(0, VALIDATION_SUMMARY_PREVIEW_LENGTH) ?? '',
    })),
  };

  const serialized = JSON.stringify(payload, null, 2);

  return [
    'Validate this taxonomy plan and identify any logical errors or quality issues.',
    '',
    'Here is the plan and context:',
    serialized,
    '',
    'Check for:',
    '- Generic folder names at top level (Misc, Personal, Other should be subfolders, not top-level)',
    '- Rules referencing non-existent folder IDs',
    '- Too flat structure (all files in 1-2 folders)',
    '- Too deep structure (unnecessary nesting beyond 3-4 levels)',
    '- Vague folder names (should be specific like "Work/Invoices/2024", not "Work/Stuff")',
    '',
    'If you find issues:',
    '- Provide corrected folders/rules that fix the problems',
    '- List file IDs that need optimization due to poor placement',
    '',
    'Respond with a JSON object: { "issues": [...], "correctedFolders": [...], "correctedRules": [...], "filesNeedingOptimization": [...] }. No markdown.',
  ].join('\n');
}
